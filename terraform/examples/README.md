# UMS Identity Terraform Examples

This directory contains practical examples of how to use the UMS Identity Terraform module in different scenarios.

## üìç Module Source

All examples use the remote module from Azure DevOps:
```
git::https://ums-projects@dev.azure.com/ums-projects/Unified%20microservices/_git/ums-identity-dynamodb//terraform
```

## Examples

### 1. Basic Setup (`basic/`)

A minimal configuration for getting started with UMS Identity infrastructure using the remote module.

**Use case**: Development environment, proof of concept, learning

**Features**:
- Remote module from Azure DevOps
- PAY_PER_REQUEST billing (no capacity planning required)
- Default table names with custom prefix
- Basic IAM configuration
- EC2 instance profile example

**Deploy**:
```bash
cd basic
terraform init
terraform plan
terraform apply
```

### 2. Production Setup (`production/`)

A production-ready configuration with monitoring, VPC endpoints, and security best practices using a pinned module version.

**Use case**: Production environment with high availability requirements

**Features**:
- Versioned module reference (v1.0.0)
- PROVISIONED billing for predictable costs
- CloudWatch alarms for monitoring
- VPC endpoint for private DynamoDB access
- ECS task role configuration
- Environment-specific tags and logging

**Deploy**:
```bash
cd production
terraform init
terraform plan -var="environment=prod"
terraform apply
```

### 3. Multi-Environment Setup (`multi-environment/`)

Deploy UMS Identity to multiple environments (dev, staging, prod) with a single configuration using the remote module.

**Use case**: Organizations with multiple environments

**Features**:
- Remote module for all environments
- Single configuration for multiple environments
- Environment-specific capacity settings
- Automatic IAM role creation per environment
- Configuration file generation for each environment
- Cost optimization per environment type

**Deploy**:
```bash
cd multi-environment
terraform init
terraform plan
terraform apply
```

### 4. Versioned Module (`versioned/`)

Production-ready example with version pinning and advanced configuration management.

**Use case**: Production deployments requiring strict version control

**Features**:
- Variable-controlled module versioning
- Environment-specific configurations
- AWS Systems Manager integration for secrets
- Comprehensive tagging including module version
- Production-grade security settings

**Deploy**:
```bash
cd versioned
terraform init
terraform plan -var="environment=prod" -var="module_version=v1.0.0"
terraform apply
```

## Configuration

Each example includes:
- `main.tf` - Main Terraform configuration
- Comments explaining each section
- Variable definitions
- Output values

### Customization

1. **Copy an example** that best matches your use case
2. **Modify variables** according to your requirements
3. **Add your tags** and naming conventions
4. **Configure AWS provider** with your region and credentials
5. **Deploy** using standard Terraform commands

### Common Customizations

#### Table Names
```hcl
module "ums_identity" {
  source = "../"
  
  users_table_name             = "myapp-users"
  tokens_table_name            = "myapp-tokens"
  temporary_tokens_table_name  = "myapp-temp-tokens"
  user_roles_table_name        = "myapp-user-roles"
}
```

#### Capacity Settings
```hcl
module "ums_identity" {
  source = "../"
  
  billing_mode = "PROVISIONED"
  
  users_read_capacity  = 20
  users_write_capacity = 10
  
  tokens_read_capacity  = 15
  tokens_write_capacity = 8
}
```

#### Tags
```hcl
module "ums_identity" {
  source = "../"
  
  common_tags = {
    Environment = "prod"
    Project     = "MyApp"
    CostCenter  = "Engineering"
    Owner       = "TeamName"
  }
}
```

## Best Practices

### Environment Isolation
- Use separate AWS accounts or regions for environments
- Use environment-specific table names
- Apply appropriate tags for cost tracking

### Security
- Enable encryption at rest: `enable_encryption = true`
- Enable point-in-time recovery: `enable_point_in_time_recovery = true`
- Use least privilege IAM policies
- Consider VPC endpoints for private access

### Cost Optimization
- Use PAY_PER_REQUEST for development/testing
- Use PROVISIONED with auto-scaling for production
- Monitor usage with CloudWatch
- Set up billing alerts

### Monitoring
- Set up CloudWatch alarms for throttling
- Monitor consumed capacity
- Track error rates
- Use AWS X-Ray for distributed tracing

## Integration with Applications

### .NET Configuration

Use the generated configuration in your application:

```csharp
// appsettings.json (generated by Terraform)
{
  "Identity": {
    "DynamoDb": {
      "UsersTable": "ums-dev-identity-users",
      "TokensTable": "ums-dev-identity-tokens",
      "TemporaryTokensTable": "ums-dev-identity-temporary-tokens",
      "UserRolesTable": "ums-dev-identity-user-roles"
    }
  }
}

// Program.cs
builder.Services.AddUmsIdentity(builder.Configuration);
```

### IAM Role Usage

For ECS tasks:
```json
{
  "taskRoleArn": "arn:aws:iam::123456789:role/ums-prod-identity-ecs-task-role"
}
```

For EC2 instances:
```hcl
resource "aws_instance" "app" {
  iam_instance_profile = aws_iam_instance_profile.app_profile.name
  # ... other configuration
}
```

## Troubleshooting

### Common Issues

1. **Permission Errors**
   - Ensure AWS credentials are configured
   - Verify IAM permissions for Terraform user

2. **Table Name Conflicts**
   - Use unique table names per environment
   - Check existing tables in AWS Console

3. **Capacity Errors**
   - Start with PAY_PER_REQUEST for testing
   - Monitor usage before setting PROVISIONED capacity

### Getting Help

- Check [main module documentation](../README.md)
- Review AWS DynamoDB documentation
- Check Terraform AWS provider documentation

## Contributing

To add a new example:

1. Create a new directory under `examples/`
2. Include a complete `main.tf` with comments
3. Document the use case and features
4. Test the example thoroughly
5. Update this README

## Next Steps

After deploying infrastructure:

1. **Configure your application** using the generated configuration
2. **Set up monitoring** with CloudWatch dashboards
3. **Configure backups** if using point-in-time recovery
4. **Test your application** with the new infrastructure
5. **Set up CI/CD** for automated deployments
